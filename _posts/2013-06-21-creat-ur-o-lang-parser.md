---
layout: post
title: "创造一个自己的开发语言 （Parser）"
description: ""
category: learn
tags: [tec]
---
{% include JB/setup %}

The lexer produces an array of tokens; the parser produces a tree of nodes.

##PARSER
上节中lexer将代码解析成下面的一组tokens.

    [IDENTIFIER print] [STRING "I ate"] [COMMA]
                        [NUMBER 3] [COMMA]
                        [IDENTIFIER pies]

大部分parser的输出是抽象语法树(`AST`),上面的tokens通过parser讲输出下面：

    [<Call name=print,
    arguments=[<String value="I ate">,
                       <Number value=3>,
                       <Local name=pies>]
    >]

直观的样子

![curol-parser-1.jpg](/assets/image/post/curol-parser-1.jpg)

编程语言和一般人类语言一样，需要有一个语法定义它的规则。分析程序生成器(parser generator)按照语法规则讲tokens转换成AST。下面介绍几个分析程序生成器。

###BISON (YACC)

yacc是一个经典的生成语法分析器的工具.yacc生成的编译器主要是用C语言写成的语法解析器（Parser），需要与词法解析器Lex一起使用，再把两部份产生出来的C程序一并编译。yacc本来只在Unix系统上才有，但现时已普遍移植往Windows及其他平台,而且还移植到其他的目标语言。
* Racc for Ruby 
* Ply for Python 
* JavaCC for Java

Yacc compiles a grammar into a parser.下面是yacc语法规则的定义：
    Call: /* Name of the rule */
       Expression '.' IDENTIFIER                  { $$ = CallNode_new($1, $3, NULL); }
     | Expression '.' IDENTIFIER '(' ArgList ')'  { $$ = CallNode_new($1, $3, $5); }
    ;


###LEMON
LEMON和yacc很像，下面是他们网站上列的不同点

* Using a different grammar syntax which is less prone to programming errors.
* The parser generated by Lemon is both re-entrant and thread-safe.
* Lemon includes the concept of a non-terminal destructor, which
makes it much easier to write a parser that does not leak memory.

###ANTLR

ANTLR，Another Tool for Language Recognition，其前身是PCCTS，它为包括Java，C++，C#在内的语言提供了一个通过语法描述来自动构造自定义语言的识别器（recognizer），编译器（parser）和解释器（translator）的框架。ANTLR可以通过断言（Predicate）解决识别冲突；支持动作（Action）和返回值（Return Value）来；更棒的是，它可以根据输入自动生成语法树并可视化的显示出来（这一点我将在下面的例子中演示）。由此，计算机语言的翻译变成了一项普通的任务—在这之前YACC/LEX显得过于学院派，而以LL（k）为基础的ANTLR虽然在效率上还略有不足，但是经过近些年来的升级修改，使得ANTLR足以应付现存的绝大多数应用。感谢Terence Parr博士和他的同事们十几年来的出色工作，他们为编译理论的基础和语言工具的构造做了大量基础性工作，也直接导致了ANTLR的产生。

ANTLR将词法分析器(Lexer)、语法分析器（Parser）、树分析器 (tree parser)结合起来，它允许我们定义识别字符流的词法规则和用于解释Token流的词法分析规则。然后，ANTLR将根据用户提供的语法文件自动生成相应的词法/语法分析器。用户可以利用他们将输入的文本进行编译，并转换成其他形式（如AST—Abstract Syntax Tree，抽象的语法树）。

它已经移植到多个目标语言。

    1.1 词法分析器（Lexer）
    词法分析器又称为Scanner，Lexical analyser和Tokenizer。程序设计语言通常由关键字和严格定义的语法结构组成。编译的最终目的是将程序设计语言的高层指令翻译成物理机器或虚拟机可以执行的指令。词法分析器的工作是分析量化那些本来毫无意义的字符流，将他们翻译成离散的字符组（也就是一个一个的Token），包括关键字，标识符，符号（symbols）和操作符供语法分析器使用。

    1.2 语法分析器（Parser）
    编译器又称为Syntactical analyser。在分析字符流的时候，Lexer不关心所生成的单个Token的语法意义及其与上下文之间的关系，而这就是Parser的工作。语法分析器将收到的Tokens组织起来，并转换成为目标语言语法定义所允许的序列。
    无论是Lexer还是Parser都是一种识别器，Lexer是字符序列识别器而Parser是Token序列识别器。他们在本质上是类似的东西，而只是在分工上有所不同而已。

    1.3 树分析器 (tree parser)
    树分析器可以用于对语法分析生成的抽象语法树进行遍历，并能执行一些相关的操作。

###PEGS

Parsing Expression Grammars，是一个非常强大的编译复杂语言的工具。
[Treetop](http://treetop.rubyforge.org)是一个非常有趣的创建PEG工具。

##OPERATOR PRECEDENCE
操作符优先权 是语言编译过程中一个难点，x + y * z 就不能编译成和 （x + y）* z.
每种语言都有一张运算符优先权表， 一般都是基于算术运算的。有很多现成的处理这个问题的工具。

>Yacc-based parsers implement the [`Shunting Yard algorithm`](http://en.wikipedia.org/wiki/Shunting_yard_algorithm) in which you give a precedence level to each kind of operator. Operators are declared in Bison and Yacc with %left and %right macros. Read more in [`Bison’s manual`](http://dinosaur.compilertools.net/bison/bison_6.html#SEC51).

下面要展示就是我们自己语言的操作符优先权表，是基于C语言的操作符优先权的[C language operator precedence](http://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B#Operator_precedence)。
    left  '.'
    right '!'
    left  '*' '/'
    left  '+' '-'
    left  '>' '>=' '<' '<='
    left  '==' '!='
    left  '&&'
    left  '||'
    right '='
    left  ',' 

优先权越高的运算符，越先编译。a + b * c 编译的时候，由于’*‘的优先级高于’+‘，所以b * c将先编译。如果所有操作符优先级一样，那么求值顺序就取决于它们的 结合性(associativity).操作符的结合性就是单词前面`left`和`right`关键词定义的。表达式a + b + c,由于’=‘的结合性是从右到左的，所以求值结果就是 a = (b = c).

###CONNECTING THE LEXER AND PARSER IN AWESOME
从头开始写个parser要比写个lexer难得多。 所以我们将用Yacc的ruby版本Racc作为Awesome的编译器。但是出于速度和更好的错误报告，大部分语言最后还是写了自己的编译器。
提供给Racc的语法文件和yacc类似。file





